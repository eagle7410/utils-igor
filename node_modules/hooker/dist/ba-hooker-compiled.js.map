{"version":3,"sources":["ba-hooker.js"],"names":[],"mappings":"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","file":"ba-hooker-compiled.js","sourcesContent":["/*! JavaScript Hooker - v0.2.3 - 1/29/2012\n* http://github.com/cowboy/javascript-hooker\n* Copyright (c) 2012 \"Cowboy\" Ben Alman; Licensed MIT */\n\n(function(exports) {\n  // Get an array from an array-like object with slice.call(arrayLikeObject).\n  var slice = [].slice;\n  // Get an \"[object [[Class]]]\" string with toString.call(value).\n  var toString = {}.toString;\n\n  // I can't think of a better way to ensure a value is a specific type other\n  // than to create instances and use the `instanceof` operator.\n  function HookerOverride(v) { this.value = v; }\n  function HookerPreempt(v) { this.value = v; }\n  function HookerFilter(c, a) { this.context = c; this.args = a; }\n\n  // When a pre- or post-hook returns the result of this function, the value\n  // passed will be used in place of the original function's return value. Any\n  // post-hook override value will take precedence over a pre-hook override\n  // value.\n  exports.override = function(value) {\n    return new HookerOverride(value);\n  };\n\n  // When a pre-hook returns the result of this function, the value passed will\n  // be used in place of the original function's return value, and the original\n  // function will NOT be executed.\n  exports.preempt = function(value) {\n    return new HookerPreempt(value);\n  };\n\n  // When a pre-hook returns the result of this function, the context and\n  // arguments passed will be applied into the original function.\n  exports.filter = function(context, args) {\n    return new HookerFilter(context, args);\n  };\n\n  // Execute callback(s) for properties of the specified object.\n  function forMethods(obj, props, callback) {\n    var prop;\n    if (typeof props === \"string\") {\n      // A single prop string was passed. Create an array.\n      props = [props];\n    } else if (props == null) {\n      // No props were passed, so iterate over all properties, building an\n      // array. Unfortunately, Object.keys(obj) doesn't work everywhere yet, so\n      // this has to be done manually.\n      props = [];\n      for (prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          props.push(prop);\n        }\n      }\n    }\n    // Execute callback for every method in the props array.\n    var i = props.length;\n    while (i--) {\n      // If the property isn't a function...\n      if (toString.call(obj[props[i]]) !== \"[object Function]\" ||\n        // ...or the callback returns false...\n        callback(obj, props[i]) === false) {\n        // ...remove it from the props array to be returned.\n        props.splice(i, 1);\n      }\n    }\n    // Return an array of method names for which the callback didn't fail.\n    return props;\n  }\n\n  // Monkey-patch (hook) a method of an object.\n  exports.hook = function(obj, props, options) {\n    // If the props argument was omitted, shuffle the arguments.\n    if (options == null) {\n      options = props;\n      props = null;\n    }\n    // If just a function is passed instead of an options hash, use that as a\n    // pre-hook function.\n    if (typeof options === \"function\") {\n      options = {pre: options};\n    }\n\n    // Hook the specified method of the object.\n    return forMethods(obj, props, function(obj, prop) {\n      // The original (current) method.\n      var orig = obj[prop];\n      // The new hooked function.\n      function hooked() {\n        var result, origResult, tmp;\n\n        // Get an array of arguments.\n        var args = slice.call(arguments);\n\n        // If passName option is specified, prepend prop to the args array,\n        // passing it as the first argument to any specified hook functions.\n        if (options.passName) {\n          args.unshift(prop);\n        }\n\n        // If a pre-hook function was specified, invoke it in the current\n        // context with the passed-in arguments, and store its result.\n        if (options.pre) {\n          result = options.pre.apply(this, args);\n        }\n\n        if (result instanceof HookerFilter) {\n          // If the pre-hook returned hooker.filter(context, args), invoke the\n          // original function with that context and arguments, and store its\n          // result.\n          origResult = result = orig.apply(result.context, result.args);\n        } else if (result instanceof HookerPreempt) {\n          // If the pre-hook returned hooker.preempt(value) just use the passed\n          // value and don't execute the original function.\n          origResult = result = result.value;\n        } else {\n          // Invoke the original function in the current context with the\n          // passed-in arguments, and store its result.\n          origResult = orig.apply(this, arguments);\n          // If the pre-hook returned hooker.override(value), use the passed\n          // value, otherwise use the original function's result.\n          result = result instanceof HookerOverride ? result.value : origResult;\n        }\n\n        if (options.post) {\n          // If a post-hook function was specified, invoke it in the current\n          // context, passing in the result of the original function as the\n          // first argument, followed by any passed-in arguments.\n          tmp = options.post.apply(this, [origResult].concat(args));\n          if (tmp instanceof HookerOverride) {\n            // If the post-hook returned hooker.override(value), use the passed\n            // value, otherwise use the previously computed result.\n            result = tmp.value;\n          }\n        }\n\n        // Unhook if the \"once\" option was specified.\n        if (options.once) {\n          exports.unhook(obj, prop);\n        }\n\n        // Return the result!\n        return result;\n      }\n      // Re-define the method.\n      obj[prop] = hooked;\n      // Fail if the function couldn't be hooked.\n      if (obj[prop] !== hooked) { return false; }\n      // Store a reference to the original method as a property on the new one.\n      obj[prop]._orig = orig;\n    });\n  };\n\n  // Get a reference to the original method from a hooked function.\n  exports.orig = function(obj, prop) {\n    return obj[prop]._orig;\n  };\n\n  // Un-monkey-patch (unhook) a method of an object.\n  exports.unhook = function(obj, props) {\n    return forMethods(obj, props, function(obj, prop) {\n      // Get a reference to the original method, if it exists.\n      var orig = exports.orig(obj, prop);\n      // If there's no original method, it can't be unhooked, so fail.\n      if (!orig) { return false; }\n      // Unhook the method.\n      obj[prop] = orig;\n    });\n  };\n}(typeof exports === \"object\" && exports || this));\n"]}