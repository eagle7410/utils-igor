{"version":3,"sources":["ensureAsync.js"],"names":[],"mappings":"AAAA;;AAEA,OAAO,cAAP,CAAsB,OAAtB,EAA+B,YAA/B,EAA6C;AACzC,WAAO;AADkC,CAA7C;AAGA,QAAQ,OAAR,GAAkB,WAAlB;;AAEA,IAAI,gBAAgB,QAAQ,yBAAR,CAApB;;AAEA,IAAI,iBAAiB,uBAAuB,aAAvB,CAArB;;AAEA,IAAI,iBAAiB,QAAQ,0BAAR,CAArB;;AAEA,IAAI,kBAAkB,uBAAuB,cAAvB,CAAtB;;AAEA,SAAS,sBAAT,CAAgC,GAAhC,EAAqC;AAAE,WAAO,OAAO,IAAI,UAAX,GAAwB,GAAxB,GAA8B,EAAE,SAAS,GAAX,EAArC;AAAwD;;AAE/F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,SAAS,WAAT,CAAqB,EAArB,EAAyB;AACrB,WAAO,CAAC,GAAG,gBAAgB,OAApB,EAA6B,UAAU,IAAV,EAAgB,QAAhB,EAA0B;AAC1D,YAAI,OAAO,IAAX;AACA,aAAK,IAAL,CAAU,YAAY;AAClB,gBAAI,YAAY,SAAhB;AACA,gBAAI,IAAJ,EAAU;AACN,iBAAC,GAAG,eAAe,OAAnB,EAA4B,YAAY;AACpC,6BAAS,KAAT,CAAe,IAAf,EAAqB,SAArB;AACH,iBAFD;AAGH,aAJD,MAIO;AACH,yBAAS,KAAT,CAAe,IAAf,EAAqB,SAArB;AACH;AACJ,SATD;AAUA,WAAG,KAAH,CAAS,IAAT,EAAe,IAAf;AACA,eAAO,KAAP;AACH,KAdM,CAAP;AAeH;AACD,OAAO,OAAP,GAAiB,QAAQ,SAAR,CAAjB","file":"ensureAsync-compiled.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = ensureAsync;\n\nvar _setImmediate = require('./internal/setImmediate');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _initialParams = require('./internal/initialParams');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {Function} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    return (0, _initialParams2.default)(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                (0, _setImmediate2.default)(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\nmodule.exports = exports['default'];"]}