{"version":3,"sources":["file.js"],"names":[],"mappings":"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","file":"file-compiled.js","sourcesContent":["'use strict';\n\nvar grunt = require('../grunt');\n\n// Nodejs libs.\nvar fs = require('fs');\nvar path = require('path');\n\n// The module to be exported.\nvar file = module.exports = {};\n\n// External libs.\nfile.glob = require('glob');\nfile.minimatch = require('minimatch');\nfile.findup = require('findup-sync');\nvar YAML = require('js-yaml');\nvar rimraf = require('rimraf');\nvar iconv = require('iconv-lite');\nvar pathIsAbsolute = require('path-is-absolute');\n\n// Windows?\nvar win32 = process.platform === 'win32';\n\n// Normalize \\\\ paths to / paths.\nvar unixifyPath = function(filepath) {\n  if (win32) {\n    return filepath.replace(/\\\\/g, '/');\n  } else {\n    return filepath;\n  }\n};\n\n// Change the current base path (ie, CWD) to the specified path.\nfile.setBase = function() {\n  var dirpath = path.join.apply(path, arguments);\n  process.chdir(dirpath);\n};\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  grunt.util._.flattenDeep(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = grunt.util._.difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = grunt.util._.union(result, matches);\n    }\n  });\n  return result;\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// all matching filepaths.\nfile.match = function(options, patterns, filepaths) {\n  if (grunt.util.kindOf(options) !== 'object') {\n    filepaths = patterns;\n    patterns = options;\n    options = {};\n  }\n  // Return empty set if either patterns or filepaths was omitted.\n  if (patterns == null || filepaths == null) { return []; }\n  // Normalize patterns and filepaths to arrays.\n  if (!Array.isArray(patterns)) { patterns = [patterns]; }\n  if (!Array.isArray(filepaths)) { filepaths = [filepaths]; }\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0 || filepaths.length === 0) { return []; }\n  // Return all matching filepaths.\n  return processPatterns(patterns, function(pattern) {\n    return file.minimatch.match(filepaths, pattern, options);\n  });\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// true if any of the patterns match.\nfile.isMatch = function() {\n  return file.match.apply(file, arguments).length > 0;\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function() {\n  var args = grunt.util.toArray(arguments);\n  // If the first argument is an options object, save those options to pass\n  // into the file.glob.sync method.\n  var options = grunt.util.kindOf(args[0]) === 'object' ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return file.glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// The \"ext\" option refers to either everything after the first dot (default)\n// or everything after the last dot.\nvar extDotRe = {\n  first: /(\\.[^\\/]*)?$/,\n  last: /(\\.[^\\/\\.]*)?$/,\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = grunt.util._.defaults({}, options, {\n    extDot: 'first',\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  });\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if ('ext' in options) {\n      destPath = destPath.replace(extDotRe[options.extDot], options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// Like mkdir -p. Create a directory and any intermediary directories.\nfile.mkdir = function(dirpath, mode) {\n  if (grunt.option('no-write')) { return; }\n  // Set directory mode in a strict-mode-friendly way.\n  if (mode == null) {\n    mode = parseInt('0777', 8) & (~process.umask());\n  }\n  dirpath.split(pathSeparatorRe).reduce(function(parts, part) {\n    parts += part + '/';\n    var subpath = path.resolve(parts);\n    if (!file.exists(subpath)) {\n      try {\n        fs.mkdirSync(subpath, mode);\n      } catch (e) {\n        throw grunt.util.error('Unable to create directory \"' + subpath + '\" (Error code: ' + e.code + ').', e);\n      }\n    }\n    return parts;\n  }, '');\n};\n\n// Recurse into a directory, executing callback for each file.\nfile.recurse = function recurse(rootdir, callback, subdir) {\n  var abspath = subdir ? path.join(rootdir, subdir) : rootdir;\n  fs.readdirSync(abspath).forEach(function(filename) {\n    var filepath = path.join(abspath, filename);\n    if (fs.statSync(filepath).isDirectory()) {\n      recurse(rootdir, callback, unixifyPath(path.join(subdir || '', filename || '')));\n    } else {\n      callback(unixifyPath(filepath), rootdir, subdir, filename);\n    }\n  });\n};\n\n// The default file encoding to use.\nfile.defaultEncoding = 'utf8';\n// Whether to preserve the BOM on file.read rather than strip it.\nfile.preserveBOM = false;\n\n// Read a file, return its contents.\nfile.read = function(filepath, options) {\n  if (!options) { options = {}; }\n  var contents;\n  grunt.verbose.write('Reading ' + filepath + '...');\n  try {\n    contents = fs.readFileSync(String(filepath));\n    // If encoding is not explicitly null, convert from encoded buffer to a\n    // string. If no encoding was specified, use the default.\n    if (options.encoding !== null) {\n      contents = iconv.decode(contents, options.encoding || file.defaultEncoding, {stripBOM: !file.preserveBOM});\n    }\n    grunt.verbose.ok();\n    return contents;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to read \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, parse its contents, return an object.\nfile.readJSON = function(filepath, options) {\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    result = JSON.parse(src);\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// Read a YAML file, parse its contents, return an object.\nfile.readYAML = function(filepath, options) {\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    result = YAML.load(src);\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.problem + ').', e);\n  }\n};\n\n// Write a file.\nfile.write = function(filepath, contents, options) {\n  if (!options) { options = {}; }\n  var nowrite = grunt.option('no-write');\n  grunt.verbose.write((nowrite ? 'Not actually writing ' : 'Writing ') + filepath + '...');\n  // Create path, if necessary.\n  file.mkdir(path.dirname(filepath));\n  try {\n    // If contents is already a Buffer, don't try to encode it. If no encoding\n    // was specified, use the default.\n    if (!Buffer.isBuffer(contents)) {\n      contents = iconv.encode(contents, options.encoding || file.defaultEncoding);\n    }\n    // Actually write file.\n    if (!nowrite) {\n      fs.writeFileSync(filepath, contents, 'mode' in options ? {mode: options.mode} : {});\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to write \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\n// Or read a directory, recursively creating directories, reading files,\n// processing content, writing output.\nfile.copy = function copy(srcpath, destpath, options) {\n  if (file.isDir(srcpath)) {\n    // Copy a directory, recursively.\n    // Explicitly create new dest directory.\n    file.mkdir(destpath);\n    // Iterate over all sub-files/dirs, recursing.\n    fs.readdirSync(srcpath).forEach(function(filepath) {\n      copy(path.join(srcpath, filepath), path.join(destpath, filepath), options);\n    });\n  } else {\n    // Copy a single file.\n    file._copy(srcpath, destpath, options);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\nfile._copy = function(srcpath, destpath, options) {\n  if (!options) { options = {}; }\n  // If a process function was specified, and noProcess isn't true or doesn't\n  // match the srcpath, process the file's source.\n  var process = options.process && options.noProcess !== true &&\n    !(options.noProcess && file.isMatch(options.noProcess, srcpath));\n  // If the file will be processed, use the encoding as-specified. Otherwise,\n  // use an encoding of null to force the file to be read/written as a Buffer.\n  var readWriteOptions = process ? options : {encoding: null};\n  // Actually read the file.\n  var contents = file.read(srcpath, readWriteOptions);\n  if (process) {\n    grunt.verbose.write('Processing source...');\n    try {\n      contents = options.process(contents, srcpath, destpath);\n      grunt.verbose.ok();\n    } catch (e) {\n      grunt.verbose.error();\n      throw grunt.util.error('Error while processing \"' + srcpath + '\" file.', e);\n    }\n  }\n  // Abort copy if the process function returns false.\n  if (contents === false) {\n    grunt.verbose.writeln('Write aborted.');\n  } else {\n    file.write(destpath, contents, readWriteOptions);\n  }\n};\n\n// Delete folders and files recursively\nfile.delete = function(filepath, options) {\n  filepath = String(filepath);\n\n  var nowrite = grunt.option('no-write');\n  if (!options) {\n    options = {force: grunt.option('force') || false};\n  }\n\n  grunt.verbose.write((nowrite ? 'Not actually deleting ' : 'Deleting ') + filepath + '...');\n\n  if (!file.exists(filepath)) {\n    grunt.verbose.error();\n    grunt.log.warn('Cannot delete nonexistent file.');\n    return false;\n  }\n\n  // Only delete cwd or outside cwd if --force enabled. Be careful, people!\n  if (!options.force) {\n    if (file.isPathCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete the current working directory.');\n      return false;\n    } else if (!file.isPathInCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete files outside the current working directory.');\n      return false;\n    }\n  }\n\n  try {\n    // Actually delete. Or not.\n    if (!nowrite) {\n      rimraf.sync(filepath);\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to delete \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// True if the file is a symbolic link.\nfile.isLink = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.lstatSync(filepath).isSymbolicLink();\n};\n\n// True if the path is a directory.\nfile.isDir = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isDirectory();\n};\n\n// True if the path is a file.\nfile.isFile = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isFile();\n};\n\n// Is a given file path absolute?\nfile.isPathAbsolute = function() {\n  var filepath = path.join.apply(path, arguments);\n  return pathIsAbsolute(filepath);\n};\n\n// Do all the specified paths refer to the same path?\nfile.arePathsEquivalent = function(first) {\n  first = path.resolve(first);\n  for (var i = 1; i < arguments.length; i++) {\n    if (first !== path.resolve(arguments[i])) { return false; }\n  }\n  return true;\n};\n\n// Are descendant path(s) contained within ancestor path? Note: does not test\n// if paths actually exist.\nfile.doesPathContain = function(ancestor) {\n  ancestor = path.resolve(ancestor);\n  var relative;\n  for (var i = 1; i < arguments.length; i++) {\n    relative = path.relative(path.resolve(arguments[i]), ancestor);\n    if (relative === '' || /\\w+/.test(relative)) { return false; }\n  }\n  return true;\n};\n\n// Test to see if a filepath is the CWD.\nfile.isPathCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.arePathsEquivalent(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n\n// Test to see if a filepath is contained within the CWD.\nfile.isPathInCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.doesPathContain(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n"]}